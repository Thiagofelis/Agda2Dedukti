Lvl : Type.
PreLvl : Type.

(; pre-levels, given by the following syntax ;)
(; L ::= empty | l + n | L1 U L2 ;)
empty : PreLvl.
plus : nat.Nat -> Lvl -> PreLvl.
defac U [PreLvl]. (; U to represent set union ;)

(; levels, given by the syntax, where i are variables ;)
(; l ::= i | set n L ;)
def set : nat.Nat -> PreLvl -> Lvl.

(; a level is in canonical form when ;)
(; l = set n ((i1 + m1) U (i2 + m2) U ... ));)
(; where each variable appears only once and n >= mj for all j;)

(; an auxiliary function adding k to all nats in the pre-level ;)
def mapPlus : nat.Nat -> PreLvl -> PreLvl.
[k]       mapPlus k empty         --> empty.
[k,j,l]   mapPlus k (plus j l)    --> plus (nat.plus k j) l.
[k,l1,l2] mapPlus k (U l1 l2)   --> U (mapPlus k l1) (mapPlus k l2).

(; the following rewrite system puts levels in canonical form ;)

(; removes empty set and repeated level variables ;)
[x]          U x          empty                  --> x.
[i,j,l]      U (plus i l) (plus j l)             --> plus (nat.max i j) l.

(; flattens nested levels ;)
[i,j,k,l]    set i   (plus j (set k l))            --> set (nat.max i (nat.plus j k)) (mapPlus j l).
[i,j,k,l,tl] set i   (U (plus j (set k l)) tl)     --> set (nat.max i (nat.plus j k)) (U (mapPlus j l) tl).
[x] set nat.0 (plus nat.0 x) --> x.

(; The syntax seen by the user ;)
def 0 : Lvl := set nat.0 empty.
def s : Lvl -> Lvl := x => set (nat.s nat.0) (plus (nat.s nat.0) x).
def max : Lvl -> Lvl -> Lvl := x => y => set nat.0 (U (plus nat.0 x) (plus nat.0 y)).

